
public class MajorityElement {

    // 看到这道题之后，首先想到了两种解决方案，第一就是使用map存储每个不同元素在数组中的个数，
    // 找出最多个数的那一个元素就行了，第二种方法就是使用快排进行排序，返回排序后序列中点的元
    // 素就是所求元素。经过查看评论找到了摩尔投票的方法，查看方法原理之后用代码实现了一下。
    /**
     * 算法原理如下，假设第一个元素为众数，那么在遍历数组的时候，如果当前元素与所假设的元素相
     * 同则计数加一，如果不同则计数减一。当计数为0时，就重新假设当前元素为众数继续运算，当遍历
     * 完成时就最后一次假设的元素就是众数。
     */
    public int majorityElement(int[] nums) {
        int votes=0;
        int x =0;
        for(int num:nums){
            if(votes==0){
                x=num;
            }
            if(x==num){
                votes+=1;
            }else{
                votes -=1;
            }
        }
        return x;
    }
}